name: Hardware CI Tests

# Updated to use PAT authentication only
on:
  push:
    branches: [ main, master ]
  pull_request:
    branches: [ main, master ]
  workflow_dispatch:
    inputs:
      repository_url:
        description: 'Repository URL for Test-O-Matic-hardwareCI'
        required: false
        default: 'https://github.com/Ruggero-R/Test-O-Matic-hardwareCI-R.git'
        type: string
      test_parameters:
        description: 'Test parameters to run (e.g., serialMS, i2c, can)'
        required: false
        default: 'serialMS i2c can'
        type: string

jobs:
  hardware-tests:
    runs-on: self-hosted
    
    steps:
    - name: Checkout current repository
      uses: actions/checkout@v4
      
    - name: Clone Test-O-Matic-hardwareCI repository
      uses: actions/checkout@v4
      with:
        repository: Ruggero-R/Test-O-Matic-hardwareCI-R
        path: test-o-matic
        token: ${{ secrets.PAT_TOKEN }}
      
    # Fallback manual clone if checkout action fails  
    - name: Manual clone if checkout failed
      if: failure()
      run: |
        # Cross-platform repository cloning with authentication fallback
        repo_url="${{ github.event.inputs.repository_url }}"
        if [ -z "$repo_url" ]; then
          repo_url="https://github.com/Ruggero-R/Test-O-Matic-hardwareCI-R.git"
        fi
        echo "Repository URL: $repo_url"
        
        # Remove existing directory if it exists
        if [ -d "test-o-matic" ]; then
          echo "Removing existing test-o-matic directory..."
          rm -rf "test-o-matic"
        fi
        
        # Try different authentication methods
        clone_success=false
        
        # Method 1: Use personal access token (primary method for HTTPS URLs)
        if [[ "$repo_url" == https* ]] && [ -n "${{ secrets.PAT_TOKEN }}" ] && [ "$clone_success" = false ]; then
          echo "Attempting clone with Personal Access Token..."
          auth_url=$(echo "$repo_url" | sed "s|https://github.com/|https://${{ secrets.PAT_TOKEN }}@github.com/|")
          if git clone "$auth_url" "test-o-matic" 2>/dev/null; then
            clone_success=true
            echo "Clone successful with PAT token"
          fi
        fi
      
        # Method 2: Use GitHub token as fallback (for HTTPS URLs)
        if [[ "$repo_url" == https* ]] && [ -n "${{ secrets.GITHUB_TOKEN }}" ] && [ "$clone_success" = false ]; then
          echo "Attempting clone with GitHub token..."
          auth_url=$(echo "$repo_url" | sed "s|https://github.com/|https://${{ secrets.GITHUB_TOKEN }}@github.com/|")
          if git clone "$auth_url" "test-o-matic" 2>/dev/null; then
            clone_success=true
            echo "Clone successful with GitHub token"
          fi
        fi

        # Method 3: Try without authentication (for public repos with HTTPS)
        if [[ "$repo_url" == https* ]] && [ "$clone_success" = false ]; then
          echo "Attempting clone without authentication (public repo)..."
          export GIT_TERMINAL_PROMPT=0
          if git clone "$repo_url" "test-o-matic" 2>/dev/null; then
            clone_success=true
            echo "Clone successful without authentication"
          fi
        fi
        
        # Check if any method succeeded
        if [ "$clone_success" = false ]; then
          echo "::error::Failed to clone repository using all methods."
          echo "::error::Solutions:"
          echo "::error::1. Make the repository public, OR"
          echo "::error::2. Add a PAT_TOKEN secret with repo access, OR" 
          echo "::error::3. Ensure GITHUB_TOKEN has access to external repos"
          exit 1
        fi
        
        echo "Repository cloned successfully!"
      shell: bash
        
    - name: Set up Go
      run: |
        # Cross-platform Go setup
        echo "Checking Go installation..."
        if command -v go >/dev/null 2>&1; then
          go_version=$(go version)
          echo "Go version: $go_version"
        else
          echo "::error::Go is not installed or not in PATH"
          exit 1
        fi
      shell: bash
        
    - name: Install dependencies
      run: |
        # Cross-platform dependency installation
        echo "Installing Go dependencies..."
        cd "test-o-matic/unit-tests"
        go mod download
        if [ $? -ne 0 ]; then
          echo "::error::Failed to download Go dependencies"
          exit 1
        fi
        echo "Dependencies installed successfully!"
      shell: bash
        
    - name: Run hardware tests
      run: |
        # Cross-platform test execution with comprehensive error handling
        cd "test-o-matic/unit-tests"
        
        # Verify main.go exists
        if [ ! -f "main.go" ]; then
          echo "::error::main.go not found in $(pwd)"
          echo "::error::Available files:"
          ls -la
          exit 1
        fi
        
        test_params="${{ github.event.inputs.test_parameters }}"
        if [ -z "$test_params" ]; then
          test_params="serialMS i2c can"
        fi
        echo "Running tests with parameters: $test_params"
        
        # Build the go command with test parameters
        go_args="run main.go"
        for param in $test_params; do
          go_args="$go_args -test $param"
        done
        
        echo "Executing: go $go_args"
        echo "Working directory: $(pwd)"
        
        # Execute with comprehensive error handling
        set +e  # Don't exit immediately on error to capture exit code
        go $go_args 2>&1 | tee test_output.log  # Capture both stdout and stderr
        exit_code=${PIPESTATUS[0]}  # Get the exit code of the go command, not tee
        set -e  # Re-enable exit on error
        
        echo "Go command finished with exit code: $exit_code"
        
        # Check for error keywords in the output (case-insensitive)
        error_found=false
        if [ -f "test_output.log" ]; then
          if grep -iq -E "(error|fail|failed|failure)" test_output.log; then
            error_found=true
            echo "Error keywords detected in test output"
          fi
        fi
        
        # Check exit code and provide detailed error information
        if [ $exit_code -ne 0 ] || [ "$error_found" = true ]; then
          if [ $exit_code -ne 0 ]; then
            echo "::error::Hardware tests failed with exit code: $exit_code"
          fi
          if [ "$error_found" = true ]; then
            echo "::error::Hardware tests failed: Error keywords detected in output"
          fi
          
          echo "::group::Test Output"
          cat test_output.log 2>/dev/null || echo "No test output available"
          echo "::endgroup::"
          
          if [ "$error_found" = true ]; then
            echo "::group::Error Lines"
            echo "Lines containing error keywords:"
            grep -in -E "(error|fail|failed|failure)" test_output.log 2>/dev/null || echo "No specific error lines found"
            echo "::endgroup::"
          fi
          
          echo "::error::The Go program encountered an error during execution."
          echo "::error::Please check the test output above for more details."
          exit 1
        fi
        
        echo "Hardware tests completed successfully!"
      shell: bash
        
    - name: Upload test results
      if: always()
      run: |
        # Cross-platform test result handling
        echo "Looking for test result files..."
        
        # Check if test results exist (handle spaces in paths)
        if ls "test-o-matic/unit-tests"/test_results_*.json 1> /dev/null 2>&1; then
          echo "Test result files found:"
          ls -la "test-o-matic/unit-tests"/test_results_*.json
          
          # Create artifacts directory
          mkdir -p "artifacts"
          
          # Copy test results (handle spaces)
          cp "test-o-matic/unit-tests"/test_results_*.json "artifacts/" 2>/dev/null || echo "No test result files to copy"
          
          echo "Test results copied to artifacts directory"
          ls -la "artifacts/"
        else
          echo "No test result files found matching pattern test_results_*.json"
        fi
      shell: bash