name: Hardware CI Tests

on:
  push:
    branches: [ main, master ]
  pull_request:
    branches: [ main, master ]
  workflow_dispatch:
    inputs:
      repository_url:
        description: 'Repository URL for Test-O-Matic-hardwareCI'
        required: false
        default: 'https://github.com/Ruggero-R/Test-O-Matic-hardwareCI-R.git'
        type: string
      test_parameters:
        description: 'Test parameters to run (e.g., serialMS, i2c, can)'
        required: false
        default: 'serialMS i2c can'
        type: string

jobs:
  hardware-tests:
    runs-on: self-hosted
    
    steps:
    - name: Checkout current repository
      uses: actions/checkout@v4
      
    - name: Verify external repository accessibility
      run: |
        echo "Testing repository accessibility..."
        repo_url="https://github.com/Ruggero-R/Test-O-Matic-hardwareCI-R.git"
        
        # Test if repository exists and is accessible
        if curl -s -f -I "https://github.com/Ruggero-R/Test-O-Matic-hardwareCI-R" > /dev/null; then
          echo "✅ Repository is publicly accessible"
        else
          echo "⚠️  Repository may be private or doesn't exist"
          echo "Will attempt clone with authentication..."
        fi
        
        # Test with PAT if available
        if [ -n "${{ secrets.PAT_TOKEN }}" ]; then
          echo "PAT_TOKEN is available"
          # Test API access with PAT
          if curl -s -H "Authorization: token ${{ secrets.PAT_TOKEN }}" \
             "https://api.github.com/repos/Ruggero-R/Test-O-Matic-hardwareCI-R" > /dev/null; then
            echo "✅ PAT has access to repository"
          else
            echo "❌ PAT does not have access to repository"
          fi
        else
          echo "❌ PAT_TOKEN is not configured"
        fi
      shell: bash
      
    - name: Clone Test-O-Matic-hardwareCI repository
      id: checkout-external
      uses: actions/checkout@v4
      with:
        repository: Ruggero-R/Test-O-Matic-hardwareCI-R
        path: test-o-matic
        token: ${{ secrets.PAT_TOKEN || secrets.GITHUB_TOKEN }}
      continue-on-error: true
      
    - name: Fallback manual clone if checkout failed
      if: always()
      run: |
        # Check if checkout was successful
        if [ -d "test-o-matic" ] && [ -f "test-o-matic/.git/config" ]; then
          echo "✅ Checkout was successful, skipping manual clone"
          exit 0
        fi
        
        echo "❌ Checkout failed, attempting manual clone..."
        
        # Remove any partial clone
        if [ -d "test-o-matic" ]; then
          rm -rf "test-o-matic"
        fi
        
        repo_url="${{ github.event.inputs.repository_url }}"
        if [ -z "$repo_url" ]; then
          repo_url="https://github.com/Ruggero-R/Test-O-Matic-hardwareCI-R.git"
        fi
        echo "Repository URL: $repo_url"
        
        clone_success=false
        
        # Method 1: Use PAT token (if available)
        if [ -n "${{ secrets.PAT_TOKEN }}" ] && [ "$clone_success" = false ]; then
          echo "Attempting clone with Personal Access Token..."
          auth_url=$(echo "$repo_url" | sed "s|https://github.com/|https://${{ secrets.PAT_TOKEN }}@github.com/|")
          if git clone "$auth_url" "test-o-matic" 2>/dev/null; then
            clone_success=true
            echo "✅ Clone successful with PAT token"
          else
            echo "❌ Clone with PAT token failed"
          fi
        fi
        
        # Method 2: Use GitHub token (fallback)
        if [ -n "${{ secrets.GITHUB_TOKEN }}" ] && [ "$clone_success" = false ]; then
          echo "Attempting clone with GitHub token..."
          auth_url=$(echo "$repo_url" | sed "s|https://github.com/|https://${{ secrets.GITHUB_TOKEN }}@github.com/|")
          if git clone "$auth_url" "test-o-matic" 2>/dev/null; then
            clone_success=true
            echo "✅ Clone successful with GitHub token"
          else
            echo "❌ Clone with GitHub token failed"
          fi
        fi
        
        # Method 3: Try without authentication (for public repos)
        if [ "$clone_success" = false ]; then
          echo "Attempting clone without authentication..."
          export GIT_TERMINAL_PROMPT=0
          if git clone "$repo_url" "test-o-matic" 2>/dev/null; then
            clone_success=true
            echo "✅ Clone successful without authentication"
          else
            echo "❌ Clone without authentication failed"
          fi
        fi
        
        # Final check
        if [ "$clone_success" = false ]; then
          echo "::error::❌ All clone methods failed!"
          echo "::error::Possible issues:"
          echo "::error::1. Repository doesn't exist: $repo_url"
          echo "::error::2. Repository is private and PAT_TOKEN lacks permissions"
          echo "::error::3. PAT_TOKEN is not configured properly"
          echo "::error::4. Network connectivity issues"
          exit 1
        fi
        
        echo "✅ Repository cloned successfully!"
      shell: bash
        
    - name: Set up Go
      run: |
        # Cross-platform Go setup
        echo "Checking Go installation..."
        if command -v go >/dev/null 2>&1; then
          go_version=$(go version)
          echo "Go version: $go_version"
        else
          echo "::error::Go is not installed or not in PATH"
          exit 1
        fi
      shell: bash
        
    - name: Install dependencies
      run: |
        # Cross-platform dependency installation
        echo "Installing Go dependencies..."
        cd "test-o-matic/unit-tests"
        go mod download
        if [ $? -ne 0 ]; then
          echo "::error::Failed to download Go dependencies"
          exit 1
        fi
        echo "Dependencies installed successfully!"
      shell: bash
        
    - name: Run hardware tests
      run: |
        # Cross-platform test execution with comprehensive error handling
        cd "test-o-matic/unit-tests"
        
        # Verify main.go exists
        if [ ! -f "main.go" ]; then
          echo "::error::main.go not found in $(pwd)"
          echo "::error::Available files:"
          ls -la
          exit 1
        fi
        
        test_params="${{ github.event.inputs.test_parameters }}"
        if [ -z "$test_params" ]; then
          test_params="serialMS i2c can"
        fi
        echo "Running tests with parameters: $test_params"
        
        # Build the go command with test parameters
        go_args="run main.go"
        for param in $test_params; do
          go_args="$go_args -test $param"
        done
        
        echo "Executing: go $go_args"
        echo "Working directory: $(pwd)"
        
        # Execute with comprehensive error handling
        set +e  # Don't exit immediately on error to capture exit code
        go $go_args 2>&1 | tee test_output.log  # Capture both stdout and stderr
        exit_code=${PIPESTATUS[0]}  # Get the exit code of the go command, not tee
        set -e  # Re-enable exit on error
        
        echo "Go command finished with exit code: $exit_code"
        
        # Check for error keywords in the output (case-insensitive)
        error_found=false
        if [ -f "test_output.log" ]; then
          if grep -iq -E "(error|fail|failed|failure)" test_output.log; then
            error_found=true
            echo "Error keywords detected in test output"
          fi
        fi
        
        # Check exit code and provide detailed error information
        if [ $exit_code -ne 0 ] || [ "$error_found" = true ]; then
          if [ $exit_code -ne 0 ]; then
            echo "::error::Hardware tests failed with exit code: $exit_code"
          fi
          if [ "$error_found" = true ]; then
            echo "::error::Hardware tests failed: Error keywords detected in output"
          fi
          
          echo "::group::Test Output"
          cat test_output.log 2>/dev/null || echo "No test output available"
          echo "::endgroup::"
          
          if [ "$error_found" = true ]; then
            echo "::group::Error Lines"
            echo "Lines containing error keywords:"
            grep -in -E "(error|fail|failed|failure)" test_output.log 2>/dev/null || echo "No specific error lines found"
            echo "::endgroup::"
          fi
          
          echo "::error::The Go program encountered an error during execution."
          echo "::error::Please check the test output above for more details."
          exit 1
        fi
        
        echo "Hardware tests completed successfully!"
      shell: bash
        
    - name: Upload test results
      if: always()
      run: |
        # Cross-platform test result handling
        echo "Looking for test result files..."
        
        # Check if test results exist (handle spaces in paths)
        if ls "test-o-matic/unit-tests"/test_results_*.json 1> /dev/null 2>&1; then
          echo "Test result files found:"
          ls -la "test-o-matic/unit-tests"/test_results_*.json
          
          # Create artifacts directory
          mkdir -p "artifacts"
          
          # Copy test results (handle spaces)
          cp "test-o-matic/unit-tests"/test_results_*.json "artifacts/" 2>/dev/null || echo "No test result files to copy"
          
          echo "Test results copied to artifacts directory"
          ls -la "artifacts/"
        else
          echo "No test result files found matching pattern test_results_*.json"
        fi
      shell: bash